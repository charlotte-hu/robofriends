{"version":3,"sources":["components/Card.js","components/CardList.js","components/SearchBox.js","components/Scroll.js","components/ErrorBoundry.js","containers/App.js","serviceWorker.js","index.js"],"names":["Card","name","username","email","id","className","alt","src","CardList","robots","map","user","i","key","SearchBox","searchChange","type","placeholder","onChange","Scroll","props","style","overflowY","border","height","children","ErrorBoundry","state","hasError","error","info","this","setState","React","Component","App","onSearchChange","event","searchfield","target","value","fetch","then","response","json","users","filteredRobots","filter","robot","toLowerCase","includes","length","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","message"],"mappings":"oNAyBeA,EAvBF,SAAC,GAAiC,IAAhCC,EAA+B,EAA/BA,KAAMC,EAAyB,EAAzBA,SAAUC,EAAe,EAAfA,MAAOC,EAAQ,EAARA,GAQrC,OAEC,yBAAKC,UAAU,uDACd,yBAAKC,IAAI,SAASC,IAAG,+BAA0BH,EAA1B,cACrB,6BACC,4BAAKH,EAAL,KACA,sCAAYC,GACZ,2BAAIC,MCOOK,EArBE,SAAC,GAAgB,IAAdC,EAAa,EAAbA,OAUnB,OACC,6BACEA,EAAOC,KAAI,SAACC,EAAKC,GACjB,OAAO,kBAAC,EAAD,CAAMC,IAAKD,EAAGR,GAAIO,EAAKP,GAAIH,KAAMU,EAAKV,KAAME,MAAOQ,EAAKR,MAAOD,SAAUS,EAAKT,gBCA1EY,EAdG,SAAC,GAAoB,IAAnBC,EAAkB,EAAlBA,aACnB,OACC,yBAAKV,UAAU,OACd,2BACCA,UAAU,mCACVW,KAAK,SACLC,YAAY,gBACZC,SAAUH,MCUCI,G,MAZA,SAACC,GACf,OACC,yBAAKC,MAAO,CAACC,UAAU,SAAUC,OAAQ,kBAAmBC,OAAQ,UAKlEJ,EAAMK,YCaKC,E,kDArBd,WAAYN,GAAQ,IAAD,8BAClB,cAAMA,IACDO,MAAQ,CACZC,UAAU,GAHO,E,8DAODC,EAAMC,GACvBC,KAAKC,SAAU,CAACJ,UAAU,M,+BAI1B,OAAIG,KAAKJ,MAAMC,SACP,yDAEDG,KAAKX,MAAMK,a,GAhBOQ,IAAMC,WC0GlBC,E,kDAlFd,aAAe,IAAD,8BACb,gBAiCDC,eAAiB,SAACC,GAIjB,EAAKL,SAAS,CAACM,YAAaD,EAAME,OAAOC,SAlCzC,EAAKb,MAAQ,CAKZlB,OAAQ,GACR6B,YAAa,IAVD,E,gEAcO,IAAD,OAEnBG,MAAM,8CAEJC,MAAK,SAAAC,GACL,OAAOA,EAASC,UAGhBF,MAAK,SAAAG,GACL,EAAKb,SAAU,CAACvB,OAAQoC,S,+BAuBjB,IAAD,OAEFC,EAAiBf,KAAKJ,MAAMlB,OAAOsC,QAAO,SAAAC,GAC/C,OAAOA,EAAM/C,KAAKgD,cAAcC,SAAS,EAAKvB,MAAMW,YAAYW,kBAIjE,OAAiC,IAA7BlB,KAAKJ,MAAMlB,OAAO0C,OACd,wBAAI9C,UAAU,MAAd,WAGN,yBAAKA,UAAU,MACd,wBAAIA,UAAU,MAAd,eACA,kBAAC,EAAD,CAAWU,aAAcgB,KAAKK,iBAM9B,kBAAC,EAAD,KACC,kBAAC,EAAD,KACC,kBAAC,EAAD,CAAU3B,OAAQqC,W,GApEPb,IAAMC,WChBJkB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,MCLNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACC,kBAAC,EAAD,OAEDC,SAASC,eAAe,SDkHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBtB,MAAK,SAAAuB,GACJA,EAAaC,gBAEdC,OAAM,SAAAtC,GACLuC,QAAQvC,MAAMA,EAAMwC,a","file":"static/js/main.4b917854.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Card = ({name, username, email, id}) => {\r\n\t/*to make it easier to type in properties.\r\n\tso down below in the codes, we don't need to call it by 'props.name' etc,\r\n\tonly need to call it by 'name'*/\r\n\t/*or just put {name,email,id} instead of 'props' in above when defining the function*/\r\n\t\r\n\t// const {name, email, id} = props;\r\n\r\n\treturn ( /*can only return 1 thing and in a bracket. But now it has been\r\n\t\tupdated with the new tag, using 'Fragment': https://blog.logrocket.com/rendering-sibling-elements-react-fragments/*/\r\n\t\t<div className='bg-light-green dib br3 pa3 ma2 grow bw2 shadow-5 tc'>\r\n\t\t\t<img alt='robots' src={`https://robohash.org/${id}?200x200`}/>\r\n\t\t\t<div>\r\n\t\t\t\t<h2>{name} </h2>\r\n\t\t\t\t<h3>a.k.a. {username}</h3>\r\n\t\t\t\t<p>{email}</p>\r\n\t\t\t\t{/*props.name, props.email have to be closed in a {} because\r\n\t\t\t\tthis is written in JSX!*/}\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Card; ","import React from 'react';\r\nimport Card from './Card';\r\n\r\nconst CardList = ({ robots }) => {\r\n\t// const cardArray = robots.map((user,i) => {\r\n\t// \treturn <Card key={i} id={user.id} name={user.name} email={user.email} username={user.username} /> \r\n\r\n\t\t/*need to use 'key' here so make every child is unique, if someday one of the card was deleted,\r\n\t\tReact won't know which one was it, so better to give each child a unique name, which is the 'key'.\r\n\t\tMost of the time it would be better to use something unique and won't be changed like id, but here\r\n\t\twe use 'index', which is still risky since array items could get moved, so the index will be changed.*/\r\n\r\n\t// })\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t{robots.map((user,i) => {\r\n\t\t\t\treturn <Card key={i} id={user.id} name={user.name} email={user.email} username={user.username} /> }\r\n\t\t\t\t)}\r\n\t\t\t{/*{cardArray}*/}\r\n\t\t\t{/*here, it will return what you defined above in const 'cardArray'*/}\r\n\t\t</div>\r\n\t)\r\n}\r\n\r\nexport default CardList;","import React from 'react';\r\n\r\nconst SearchBox = ({searchChange}) => {\r\n\treturn (\r\n\t\t<div className='pa2'>\r\n\t\t\t<input \r\n\t\t\t\tclassName='pa3 ba b--green bg-lightest-blue' \r\n\t\t\t\ttype='search' \r\n\t\t\t\tplaceholder='search robots'\r\n\t\t\t\tonChange={searchChange} />\r\n\t\t\t\t{/*onChange is a JS event, listening to 'anytime the input changes'\r\n\t\t\t\tsearchChange is a function that will be called when onChange*/}\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default SearchBox;","import React from 'react';\r\n\r\n/*to create a scrollable component*/\r\n/*adding style in the div we created to make it scrollable, and wrap this around the other component that\r\nwe want it to be scrollable. And this component can be reused anywhere you want to wrap something and make\r\nit scrollable.*/\r\n\r\nconst Scroll = (props) => {\r\n\treturn (\r\n\t\t<div style={{overflowY:'scroll', border: '5px solid black', height: '800px'}}>\r\n\t\t{/*1st curly bracket above: for JSX, 2nd curly bracket above: for CSS property\r\n\t\tcss: overflow-y\r\n\t\tjsx: overflowY\r\n\t\tyou must camelCalse for JSX*/}\r\n\t\t\t{props.children}\r\n\t\t</div>\r\n\t)\r\n};\r\n\r\nexport default Scroll;","import React from 'react';\r\n\r\n\r\n/*Here we'll use 'ErrorBoundry' as a wrapping component, so we can use 'children' to call whatever\r\nit was wrapped around*/\r\nclass ErrorBoundry extends React.Component {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\thasError: false\r\n\t\t}\r\n\t}\r\n\r\n\tcomponentDidCatch(error,info) {\r\n\t\tthis.setState( {hasError: true})\r\n\t}\r\n\r\n\trender() {\r\n\t\tif (this.state.hasError) {\r\n\t\t\treturn <h1>Oooops. That is not good </h1>\r\n\t\t}\r\n\t\treturn this.props.children\r\n\t}\r\n}\r\n\r\n\r\n\r\nexport default ErrorBoundry;","import React from 'react'; \r\n\r\n// import Card from './Card';   --comment out because we used CardList here instead\r\n/*this doesn't need to use {} because in 'Card.js', it only export\r\none element*/\r\n\r\nimport CardList from  '../components/CardList';\r\n/*adding a parent of Card so that we don't need to copy/paste a lot of Card component below*/\r\n\r\n// import {robots} from './robots';\r\n/*because in 'robots.js', it is not 'default export' since it has\r\nmultiple attributes, so have to put {} to destructure it*/\r\n\r\nimport SearchBox from '../components/SearchBox';\r\nimport './App.css';\r\nimport Scroll from '../components/Scroll';\r\n\r\nimport ErrorBoundry from '../components/ErrorBoundry';\r\n\r\n\r\n/*to be able to use 'State' where SearchBox and CardList(robots) can communicate*/\r\n// const state = {\r\n// \trobots: robots, /*need to have a 'robots' array*/\r\n// \tsearchfield: '', /*whatever our search field needs*/\r\n// }\r\n\r\n/*in order to use 'State', we have to go back to original way that we created React \r\ncomponents below in 'App', where we create a 'class' instead of a 'const'*/\r\nclass App extends React.Component { /*we are extending a class from React.Component, which is an instance*/\r\n\tconstructor() { /*The constructor is a method used to initialize an object's state in a class*/\r\n\t\tsuper();\r\n\t\t/*before using 'this', we have to call 'super()' which calls the constructor of\r\n\t\tcomponent. See JS.note: ES5_ES6*/\r\n\t\tthis.state = {\r\n\t\t/*this is what we described our App, these are things that can change, and that's what\r\n\t\tthis 'state' is. Here we defined it as the initial state of this 'App'.\r\n\t\tIt usually lives in the parent component, the 'App', that just passes 'state' to \r\n\t\tdifferent components */\r\n\t\t\trobots: [], /*initial state where robots are still empty*/\r\n\t\t\tsearchfield: '' /*default as blank in searchfield*/\r\n\t\t}\r\n\t}\r\n\r\n\tcomponentDidMount() { /*when component did get mounted while the page is loaded/refreshed, we can do: (can refer to React.md)*/\r\n\t\t/*to get users from somewhere (server) in the internet instead of local 'robots.js' file*/\r\n\t\tfetch(\"https://jsonplaceholder.typicode.com/users\")\r\n\t\t/*fetch(): simply means \"go to here, the url\", and it's going to get a response */\r\n\t\t\t.then(response=> {\r\n\t\t\t\treturn response.json();\r\n\t\t\t})\r\n\t\t\t/*then(response1): the received response, converted it into a .json() */\r\n\t\t\t.then(users=> {\r\n\t\t\t\tthis.setState( {robots: users} );\r\n\t\t\t})\r\n\t\t\t/*then(response1 converted into .json()): set the response to be the value of 'robots'state*/\r\n\t\t\r\n\t\t\t/*so we are updating the states with 'then' after we fetched the users from somewhere (server)*/\r\n\t}\r\n\r\n\t/*to make up a function that will be affected by the searchbox, which we called 'onSearchChange' */\r\n\t/*remember, except for 'render()' or 'constructor()', which are pre-build method in React, everytime\r\n\tyou are building your own method, like 'onSearchChange', need to make it as an arrow function. This way\r\n\tcan make sure the 'this' in this created method, is according to where it was created, which is the 'App'*/\r\n\tonSearchChange = (event)=> {\r\n\t\t/*in order to update the state, anytime you want to change state you have to do this,\r\n\t\t'setState', not 'this.state.searchfield'. So that everytime the changes would be updated\r\n\t\tas 'searchfield' with its 'event.target.value', which is the change that triggered the state to change*/\r\n\t\tthis.setState({searchfield: event.target.value});\r\n\r\n\t\t// console.log(event.target.value);\r\n\t\t/*so we want when everytime 'SearchBox' gets input changes to trigger this function.\r\n\t\tremember always to have 'event.target.value' which should give us the value of the search term*/\r\n\t}\r\n\r\n\r\n\trender() { /*always 'render' something, it's a function to return something (of what to display)*/\r\n\t\t/*filter the robot that we input in the searchfield*/\r\n\t\tconst filteredRobots = this.state.robots.filter(robot => {\r\n\t\t\treturn robot.name.toLowerCase().includes(this.state.searchfield.toLowerCase());\r\n\t\t \t/*only return when the robot name includes as the input in searchfield*/\r\n\t\t \t/*if put this into 'onSearchChange' method, it'll work as well*/\r\n\t\t})\r\n\t\tif (this.state.robots.length === 0) { /*if the users list is too long taking many time to load in*/\r\n\t\t\treturn <h1 className='tc'>Loading</h1>\r\n\t\t} else {\r\n\t\t\treturn (\r\n\t\t\t\t<div className='tc'>\r\n\t\t\t\t\t<h1 className='f1'>RoboFriends</h1>\r\n\t\t\t\t\t<SearchBox searchChange={this.onSearchChange} />\r\n\t\t\t\t\t{/*adding a component as a searchbox to live-searching a Robofriend*/}\r\n\t\t\t\t\t{/*because 'onSearchChange' is an object, has to declare DOM, so add 'this'*/}\r\n\t\t\t\t\t{/*here we can see 'searchChange' is a prop from 'SearchBox' that is actually 'onSearchChange' function,\r\n\t\t\t\t\twhich is defined in 'App', the parent. So basically this indicated how a child 'SearchBox'\r\n\t\t\t\t\tcommunicated to its parent 'App'*/}\r\n\t\t\t\t\t<Scroll>\r\n\t\t\t\t\t\t<ErrorBoundry>\r\n\t\t\t\t\t\t\t<CardList robots={filteredRobots} />\r\n\t\t\t\t\t  \t\t{/*1. here it means 'CardList' is accepting a 'robots' props, which is a 'robots' array*/}\r\n\t\t\t\t\t\t\t{/*2. after we added 'state', we can now access 'robots' from 'this.state.robots' instead\r\n\t\t\t\t\t\t\tof what we imported from above from ./robots */}\r\n\t\t\t\t\t\t\t{/*3. now we have 'filteredRobots' fed by searchBox, so now it can be fed into CardList*/}\r\n\t\t\t\t\t\t</ErrorBoundry>\r\n\t\t\t\t\t</Scroll>\r\n\t\t\t\t\t{/*'Scroll' component here can wrap a children, ex.CardList, which it will return whatever it's \r\n\t\t\t\t\twrapping if we called 'this.children' in it owned component JS file.*/}\t\r\n\t\t\t\t</div>\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default App;\r\n\r\n/*\r\nSee above, since we want to do a search box that is interactive, while searchbox can\r\ninteract with CardList, and CardList can response to what was input in the searchbox.\r\n\r\nConsidering that 'One Way Data Flow', if we want 2 components to talk to each other,\r\nthey need to be able to send their informatino to their parent, and the parent tells\r\nthem what to do\r\n\r\n'Props' is a one way data flow concept, for example, like 'CardList' is a pure function. \r\nIt receives an input and then it always returns the same output. So if the 'Props', which is\r\nthe '{robots}', are always the same, it's always going to return the same thing. It's deterministic,\r\npure function. This type of component (like 'CardList') are called 'Pure components', or 'Dumb components'.\r\nOnly do 'Received and Return'.\r\n\r\n'State' is another thing, and it simply means the description of your app. A 'state' is simply\r\nan 'object', that describes your applications. So in this case, we want the CardList and SearchBox\r\nto communicate to each other and react, this 'state' which describes our application is the robots (CardList),\r\nand whatever is entered in the SearchBox. 'State' is able to change. We are able to change the value\r\nof the SearchBox, the value of input, able to change what gets displayed.\r\n\r\nTo conclude:\r\n\"Props are simply things that come out of State\"\r\nSo a parent feeds 'State' into a chile component, and as soon as child (component) receives a 'State',\r\nthen it's a 'Props' (property). The child can never change that property. The parent just tell the child\r\nwhat is the 'State', and the child received it as 'robots'\r\n*/\r\n\r\n/*ACTUAL COMMUNICATION BETWEEN SearchBox (Child) and App (Parent)*/\r\n/*1. When SearchBox 'onChange', it's going to run the function, to call 'searchChange' to be 'searchChange()'*/\r\n/*2. 'searchChange' function is a Prop, is the 'onSearchChange' function, which is defined in the 'App'\r\nThis is how the child communicate with the parent. So the child triggers the event, the parent says 'Oh, run this function'.*/\r\n/*3. And now we have search input, we can communicate the input to the 'robots' list.*/\r\n\r\n\r\n/////*WHAT EXACTLY HAPPEN WHEN WE ADD SEARCH FILTER*/////\r\n/*1. We have our 'App' component that has 2 states - 'robots' and 'searchfield', so the 'state' is what changed\r\nin the app, it's what describes the app -  think about the virtual DOM is just a JS object. The virtual DOM is just\r\nan object that collected the entire states (robots & searchfield), and React used these state to render and pass down\r\nas props to those components - 'SearchBox', 'Cardlist'. */\r\n/*2. Then these components - 'SearchBox' and 'CardList' are just pure functions can just render*/\r\n/*3. We manage the state in 'render()', the 'App' is the only thing that can change this state, but it\r\ncan pass down things such as props, so we passed down 'onSearchChange', which include the state 'searchfield'\r\nthat can be changed, to the component -'SearchBox' */\r\n/*4. Evert time there's an 'onChange' on the input in the 'SearchBox', it lets the 'App' know there's a change,\r\nand run this function defined as in 'onSearchChange' in 'App'.*/\r\n/*5. So it runs the function with the event, and updated the state of the 'searchfield' to whatever we type in*/\r\n/*6. Now with the information that we have from the 'searchBox, we can now communicate to the other component -'CardList',\r\nand tells it we want to filter the 'robots' state to now have only what includes in the 'searchfield'*/","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './containers/App';\r\n/*here we have a 'App' component to be the parent of all toher components, \r\nincluding CardList/Card/Searchbox/Robots...*/\r\n\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'tachyons';\r\n\r\n\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n  \t<App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}